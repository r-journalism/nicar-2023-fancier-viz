{"title":"mapbox dot density","markdown":{"yaml":{"title":"mapbox dot density","format":"html","editor":"visual"},"headingText":"Raster versus Vector","containsRefs":false,"markdown":"\n\nThese days some of the best, most complicated interactive maps are being published using Mapbox.\n\n>Raster maps are so 2012.\n\n- [Armand Emamdjomeh](https://www.washingtonpost.com/people/armand-emamdjomeh/), Graphics Reporter at The Washington Post.\n\n----\n\nIt feels like a natural evolution. In fact, a lot of the same people who developed Leaflet went on to work on Mapbox.\n\n*What's the difference?*\n\nLeaflet uses Raster Tiles while Mapbox uses Vector Tiles.\n\nIt's like creating graphics in Adobe Photoshop versus Adobe Illustrator.\n\n\n* Elements of a vector tile can be easily styled, like roads.\n\n* Vector tiles are rendered on the user end, not on the server end\n\n* It's just faster. Vector files load 20-50 percent quicker.\n\n### Mapbox on R with Mapdeck\n\nJust as someone made an R package that interfaces R with Leaflet, someone made a package in 2019 to interface with Mapbox: %>% %>%  [Mapdeck](https://symbolixau.github.io/mapdeck/index.html)\n\nIt's still really new. And it'll take some time for people to create new packages that build on top of it in R. But it's something that will definitely continue to grow in popularity.\n\n**Downside**: It's not unlimited. You'll be charged if your map gets a lot of use.\n\n## Let's reproduce this Washington Post map\n\n![](images/reproduce_aaron_armand.png)\n\nRemember [this story](https://www.washingtonpost.com/graphics/2018/national/segregation-us-cities/) about diversity and segregation? \n\nLet's see if we can get close to reproducing it.\n\n\nThe repo containing the data and scripts for this section is on Github. \nTo follow along, simply run the lines of code below in R.\n\n-----\n\n```{r eval=F}\n# There is no need to run these install lines below if you already have done so\ninstall.packages(\"usethis\")\nusethis::use_course(\"https://github.com/andrewbtran/NICAR-2020-mapping/archive/master.zip\")\n\n# This section is in scripts/05_mapbox_dotdensity.R\nfile.edit(\"scripts/05_mapbox_dotdensity.R\")\n\n```\n\n-----\n\n\n### Get an API key\n\n1. Sign up for a [Mapbox account](https://www.mapbox.com/) and generate an [Access token](https://docs.mapbox.com/help/how-mapbox-works/access-tokens/)\n\nNext, we need to load the right packages.\n\n```{r loading_packages, warning=F, message=F}\n# This function checks if you don't have the correct packages installed yet\n# If not, it will install it for you\npackages <- c(\"sf\", \"tidyverse\", \"tigris\",\n              \"tidycensus\", \"mapdeck\")\nif (length(setdiff(packages, rownames(installed.packages()))) > 0) {\n  install.packages(setdiff(packages, rownames(installed.packages())), repos = \"https://cran.us.r-project.org\")  \n}\nlibrary(sf)\nlibrary(tidyverse)\nlibrary(tigris)\nlibrary(tidycensus)\nlibrary(mapdeck)\n```\n\nThe next steps involve querying the Census API with `tidycensus` for blockgroup-level data on population by race.\n\nIt takes a while to download and requires your own [Census API key](https://api.census.gov/data/key_signup.html), so go ahead and just load the pre-downloaded data with the code below.\n\n```{r load_acs_data, warning=F, message=F}\nacs <- readRDS(\"data/acs_geoid.RDS\")\n```\n\nHere's the R code to query and download that data on your own if you want to pull for another state (or ALL of them if you've got a lot of time set aside). Be sure 1) you have a solid internet connection and 2) you have a Census API key that you can substitute in.\n\n```{r census_pull, eval=F}\ncensus_key <- \"YourCensusKeyGoesHere\"\n\ncensus_api_key(census_key)\n\n## this function downloads the data by variables we've set\nacs <- get_acs(\"block group\", table = \"B02001\", cache_table = TRUE,\n               geometry = TRUE, state = \"22\",\n               year = 2016, output = \"tidy\")\n\n## These lines cleans up the downloaded data frame\nacs <- acs %>%\n  mutate(\n    id = str_extract(variable, \"[0-9]{3}$\") %>% as.integer\n  ) %>%\n  # variable 1 is the \"total\", which is just the sum of the others\n  filter(id > 1 & id < 8) %>%\n  mutate(race =case_when(\n    id == 2 ~ \"White\",\n    id == 3 ~ \"Black\",\n    id == 4 ~ \"Native\",\n    id == 5 | id == 6 ~ \"Asian\",\n    id == 7 ~ \"Other\"\n  )) %>% \n  group_by(GEOID, race) %>% \n  summarise(estimate = sum(estimate))\n\n```\n\nThis is what the downloaded data from the Census looks like:\n\n```{r glimpse1}\nglimpse(acs)\n```\n\nNotice the geometry column? That's where the polygon data resides but in a tidy format.\n\nLet's quickly render this on a map to see what we've downloaded from the Census API and what we're working with.\n\nFirst, let's look at just one variable in the map.\n\n```{r polygon, fig.width=8, fig.height=5}\n# let's look at one variable so it doesn't throw off the map\nacs_black <- acs %>%\n  filter(race==\"Black\")\n\nglimpse(acs_black)\n```\n\nLet's load the mapdeck library and put in the [Mapbox API key](https://account.mapbox.com/access-tokens/).\n\n```{r mapdeck1}\nlibrary(mapdeck)\n\nmb_key <- \"PutYourKeyHere\"\n```\n\n```{r mbkey, echo=F}\nsource(\"key.R\")\n```\n\n\n```{r mapbox1, fig.width=8, fig.height=5}\n\nmapdeck(token = mb_key, style = mapdeck_style(\"dark\")) %>%\n  add_polygon(\n    data = acs_black,\n    fill_colour = \"estimate\",\n    fill_opacity = .4\n  )\n  \n```\n\nSo how do we get from numbers tied to a polygon to dots on a map?\n\nThere's a function in the `sf` package called `st_sample()`\n\nRun this line of code to get the end result.\n\n```{r load_data, warning=F, message=F}\npoints <- readRDS(\"data/points_exported.RDS\")\n\nglimpse(points)\n```\n\nIt requires a lot of computing power to generate these samples of latitude and longitude per dot.\n\nThe code below generated the data loaded above. It could take a while to a long while for the query to run depending on the number of dots you want to plot within a polygon.\n\n```{r sampling, eval=F}\n## Only run these lines of code if you have a lot of free time\n## You can adjust the number of dots generated by \n## dividing the estimate below (in this instance the denominator is 100)\n## \ngenerate_samples <- function(data) \n  suppressMessages(st_sample(data, size = round(data$estimate / 100)))\n\n\npoints <- map(acs_split, generate_samples)\npoints <- imap(points, \n               ~st_sf(data_frame(race = rep(.y, length(.x))),\n                      geometry = .x))\npoints <- do.call(rbind, points)\n\npoints <- points %>% group_by(race) %>% summarise()\n```\n\nHow's this new data look?\n\n```{r points_preview}\npoints %>% mutate(n_points = map_int(geometry, nrow))\n```\n\nOkay, let's start to visualize the data using mapdeck.\n\nStart by adding some color styles so it matches the Post's map.\n\nAnd then we'll use the `mapdeck()` function, and supply it with they API key and tile style we want.\n\nThe function for dots in mapdeck is `add_scatterplot()` and we can specify what data to refer to as well as what styles to use.\n\n```{r mapdeck2, fig.width=8, fig.height=5, warning=F, message=F}\n# setting up a color palette\nm <- grDevices::colorRamp(c(\"aquamarine2\", \"dodgerblue2\", \"orange\", \"gray\", \"firebrick3\"))(1:256/256)\n\n# reordering the dataframe so the most populous is drawn on the map first\npoints <- points %>% \n  mutate(order=case_when(\n    race==\"White\" ~ 1,\n    race==\"Black\" ~ 2,\n    race==\"Asian\" ~ 3,\n    race==\"Native\" ~ 4,\n    race==\"Other\" ~ 5,\n    TRUE ~ 6\n  )) %>% \n  arrange(order)\n\n# New map\nmapdeck(token = mb_key, \n        style = 'mapbox://styles/mapbox/dark-v9',\n        zoom = 6,\n        location = c(-92.394604, 31.091401)) %>% \n  add_scatterplot(\n    data=points,\n    radius=1,\n    fill_opacity=.3,\n    fill_colour = \"race\",\n    palette = m,\n    layer_id = \"scatter_layer\",\n    update_view= FALSE,\n    #, tooltip = \"race\"\n    legend=T\n  )\n```\n\nPretty close, right?\n\nBut you zoom in and there's some oddities, like dots in the water.\n\nYou can fix that with some R functions from the [**tigris** package](https://walkerke.github.io/tidycensus/articles/spatial-data.html).\n\nFor now, enjoy what you've made.\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"mapbox-dot-density.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.251","theme":"cosmo","title":"mapbox dot density","editor":"visual"},"extensions":{"book":{"multiFile":true}}}}}